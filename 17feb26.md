# 17 february 2026 OOP
## Structure

basic syntax
```cpp
struct StructureName {
    dataType member1;
    dataType member2;
    dataType member3;
};
```

usage example:

```cpp
#include <iostream>
using namespace std;

struct Student {
    string name;
    int age;
    float marks;
};

int main() {
    Student s1;

    s1.name = "John";
    s1.age = 20;
    s1.marks = 85.5;

    cout << "Name: " << s1.name << endl;
    cout << "Age: " << s1.age << endl;
    cout << "Marks: " << s1.marks << endl;

    return 0;
}
```

## Object oriented programming

- `Structure` can only contain variables (data members).  
- whereas `Class` can hold variables as well as relevant functions called `methods`.  

## `Class`
basic syntax: 

```cpp
#include <iostream>
#include <math.h>
using namespace std;

class Coordinate
{
    private:
        int x_val, y_val;
    public: 
        Coordinate(int x, int y){
            this->x_val = x;
            this->y_val = y;
        }
        float distance(const Coordinate& other){
            float x_dist = pow((this->x_val - other.x_val), 2);
            float y_dist = pow((this->y_val - other.y_val), 2);
            return pow((x_dist + y_dist), 0.5);
        }
};

int main(){
    Coordinate source(0,0);
    Coordinate dest(3,4);
    float dist = source.distance(dest);
    cout << "The distance is : " << dist;
    return 0;
}
```
output:
```md
The distance is : 5
```
  
### `this->`
here `this` is a pointer to current object.  
we need it when parameter names are same as member names.  
and here in this code, we don't really need `this->` but it's required when there is conflict b/w parameter names and member names.  

### another way of creating an object
```cpp
int main(){
    Coordinate* source = new Coordinate(0,0);
    Coordinate dest(3,4);
    float dist = source->distance(dest);
    cout << "The distance is: " << dist << endl;
    return 0;
}
```
so here we see, incase of an object we use `.` specifier and when we have a pointer of the object, we use `->` specifier.  

---

## Linked list

we will create a class `Node` whose each object will represent a node of the linked list.  
inside that node, we would define multiple properties like `next`, `prev`, `data`, etc.  

```cpp
class Node
{
    public:
        int data;
        Node* next;
        Node(int val){
            data = val;
            next = NULL;
        }
};

class SinglyLinkedList
{
    private:
        Node* head; // head itself is not a node, but just a node pointer that points to the first node
    public:
        void Dislpay(){
            if (head == NULL){
                cout << "The list is empty\n";
                return;
            }
            Node* temp = head;
            while(temp->next != NULL)
            {
                cout << temp->data << " ->";
                temp = temp->next;
            }
            cout << "Null\n";
        }
        void InsertAtBeginning(int val){
            Node* newNode = new Node(val);
            newNode->next = head;
            head = newNode;
            cout << "Inserted at the beginning\n";
        }
        void InsertAtEnd(int val){
            //check if list is already empty then call InsertAtBeginning(val)
            Node* newNode = new Node(val);
            Node* temp = head;
            while(temp->next!=NULL){
                temp = temp->next;
            }
            temp->next = newNode;
            cout << "Inserted at the end\n";
        }
        void Insert(int val, int pos){
            if (pos == 0){
                InsertAtBeginning(val);
                return;
            }
            Node* newNode = new Node(val);
            Node* temp = head;
            int i = 0;
            while (i<pos && temp->next!=NULL){
                temp = temp->next;
                i++;
            }
            newNode->next = temp->next;
            temp->next = newNode;
            cout << "Inserted at " << pos << "th position\n";
        }
        
};
```